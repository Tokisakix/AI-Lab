# 遗传算法解决TSP问题

## 文件结构

* `main.py`: 主函数。

* `Task.pdf`: 任务描述。

* `Tutor.pptx`: 实验课件。

* `data/`：数据集。

* `results/`: 执行结果。

**NOTE:** 不建议尝试城市数量 $\ge 500$ 的数据集。

## 算法原理

### TSP问题

旅行商问题（Traveling Salesman Problem, TSP）是组合优化中的一个经典问题。

考虑$n$个城市，其间距离构成一个$n \times n$的距离矩阵$D = \{d_{ij}\}$，$d_{ij}$代表城市$i$和城市$j$之间的距离。

TSP问题的目标是找到一个城市的排列$\pi$，使得总旅程长度$L(\pi)$最小：

$$
L(\pi) = \sum_{i=1}^{n-1}d_{\pi(i)\pi(i+1)} + d_{\pi(n)\pi(1)}
$$

其中$\pi(i)$表示排列中的第$i$个城市。

### 遗传算法

遗传算法（Genetic Algorithm, GA）是一种模拟自然进化过程的搜索启发式算法，用于生成高质量的解决方案来解决优化、搜索问题。

遗传算法反复修改一种候选解的群体。在每一代中，对群体中的个体评估适应度，然后从当前种群中选择更适合的个体，并使用交叉、变异操作生成新的生命种群，引导种群朝着最优解进化。

### 使用遗传算法解决TSP问题

本次实验中，我们将探索遗传算法在TSP问题中的使用。遗传算法会在庞大的搜索空间中不断迭代，尽可能逼近最优解。其关键步骤如下：

**编码**

首先，我们需要把TSP的解编码为遗传算法中的染色体。

考虑$n$个城市，我们定义TSP问题的染色体是一个整数排列$\pi$，表示访问城市的顺序，其中$\pi(i) \in \{1, 2, ..., n\}$是不同城市的编号。

**适应度函数**

为了判断一个染色体的好坏，我们进一步定义适应度函数。我们取适应度函数为路径总长度的倒数：
$$
Fitness(\pi) = \frac{1}{L(\pi)}
$$
其中，$L(\pi)$是路径$\pi$的总长度。计算方法为：

$$
L(\pi) = \sum_{i=1}^{n-1}d_{\pi(i)\pi(i+1)} + d_{\pi(n)\pi(1)}
$$
$d_{ij}$表示城市$i$和$j$之间的距离。这样，路径长度越短，适应度值越高。

**选择**

我们采用轮盘赌选择方法，从当前种群中选择个体进行交叉，以生成子代个体。

对于种群中的某个体$i$，其被选择的概率$P(i)$​定义为：
$$
P(i) = \frac{Fitness(i)}{\sum_{j=1}^{N} Fitness(j)}
$$
其中，$N$是种群的大小。

**交叉**

考虑两个父个体$p1$和$p2$。其通过下述步骤，交叉产生子代$c1$和$c2$：

1. 随机选择两个交叉点$s$和$t$。
2. $c1$的$s$到$t$段直接复制自$p1$，$c2$的$s$到$t$段直接复制自$p2$。
3. 根据第二步的映射关系，修改$c1$和$c2$的剩余部分，保证每个城市只出现一次。

**变异**

在交叉生成新的子代个体后，我们考虑在子代个体上进行倒置变异，随机改变其部分染色体，来引入新的遗传多样性。

对于子代个体的染色体$\pi$，我们随机选取$\pi$上的两个点$i$和$j$，把$\pi(i)\sim \pi(j)$倒置。变异后的染色体为：
$$
\pi' = [\pi(1), ..., \pi(j), ..., \pi(i), ..., \pi(n)]
$$
总的来讲，遗传算法通过编码、适应度计算、选择、交叉、变异这五个核心步骤，不断迭代进化，逐步逼近TSP问题的最优解。




