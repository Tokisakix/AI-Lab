# ResolutionFOL

## 文件结构

* `Task.pdf`: 任务描述。

* `Tutor.pdf`: 实验课件。

* `ResolutionFOL.py`: 主逻辑代码。

* `test.py`：用于测试的代码。

* `requirements.txt`: 项目需求环境。

本仓库的代码可以处理像这样的复杂子句：

$$
\text{Predicate}(f(g(h(x))))
$$

命令行下，使用`pytest -s test.py`进行测试。


## 算法原理

###  基本概念

归结原理是一种自动推理技术，用于判断一个逻辑公式集（知识库）是否蕴含某个特定的公式。这种方法特别适用于命题逻辑和一阶谓词逻辑。

在逻辑领域中，一个**子句**是一系列文字的析取（即“或”关系的连接），例如 $A \lor \neg B$。一个**文字**是一个原子或其否定，其中**原子**是最基本的不可分割的公式单位。

### 命题逻辑归结算法

命题逻辑归结算法的核心思想是通过反复应用归结规则来简化公式，直到得到一个空子句或无法进一步归结为止。归结规则如下所示：

如果有两个子句 $C_1: A \lor P$ 和 $C_2: \neg A \lor Q$，其中 $A$ 是一个文字，$P$ 和 $Q$ 是文字的析取（可能为空），那么我们可以得到一个新的子句 $C: P \lor Q$。

这个过程称为**归结**，新产生的子句 $C$ 称为 $C_1$ 和 $C_2$ 的**归结子**。

### MGU算法

在一阶逻辑中，变量的引入使得我们需要通过合一算法来确定是否存在一个变量的替换，使得两个谓词能够匹配。**最一般合一（MGU）**是这样的变量替换，它能使得两个表达式相等，且在所有能使这两个表达式相等的替换中是最一般的。

如果有两个表达式 $E_1$ 和 $E_2$，MGU是一个替换集合 $\sigma$，使得 $E_1\sigma = E_2\sigma$，且对于任何其他使 $E_1$ 和 $E_2$ 相等的替换 $\sigma'$，都存在替换 $\theta$ 使得 $\sigma'\theta = \sigma$。

### 一阶逻辑归结算法

一阶逻辑归结算法是基于归结原理的自动推理技术，用于判断一组一阶逻辑公式（知识库 KB）是否蕴含某个特定公式 $\alpha$。算法主要包括以下步骤：

1. **转换为Skolem标准形**：

   将所有公式转换为**前束范式**（所有量词出现在公式前部）。

   应用**Skolem化**消除存在量词（$\exists$）。通过引入Skolem函数或常量，将量词全部转化为全称量词（$\forall$）的形式。

2. **子句化**：

   将Skolem标准形的公式转换为一组子句的合取形式，其中每个子句是一组文字的析取。

   此步骤包括消除全称量词、将公式转换为合取范式（CNF），然后提取子句。

3. **归结推理过程**：

   **输入**：知识库 $KB$ 和查询 $\alpha$。

   **输出**：判断 $KB \models \alpha$ 是否成立。

   **步骤**：

   1. 将 $KB \cup \{\neg \alpha\}$ 转换为一组子句 $S$。
   2. 对于 $S$ 中的任意两个子句 $C_1$ 和 $C_2$，如果它们可以通过MGU $\sigma$ 归结得到子句 $C$，则 $C \sigma$ 加入到 $S$ 中。
   3. 重复步骤2，直到生成空子句或无法进一步归结为止。
   4. 如果生成了空子句，则 $KB \models \alpha$；否则，$KB \nvDash \alpha$。
